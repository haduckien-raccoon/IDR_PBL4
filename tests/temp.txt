# ----------------- Old simple match_payload (byte + regex only) -----------------
        
#     def match_payload(self, payload: bytes, meta: Dict[str, Any]):
#         p = payload[: self.payload_bytes]
#         variants = generate_decodes(p, self.enable_decode)
#         hits: List[Tuple[str,str,str]] = []

#         if self.aho:
#             try:
#                 s_raw = p.decode('latin1', errors='ignore')
#                 for end_index, (idx, rid, message) in self.aho.iter(s_raw):
#                     hits.append((rid, message, "AHO_raw"))
#             except Exception:
#                 console_logger.debug("AHO error", exc_info=True)

#         for entry in self.compiled:
#             r = entry["rule"]
#             rule_proto = (r.get("proto") or "ANY").upper()
#             if rule_proto != "ANY" and str(meta.get("proto") or "").upper() != rule_proto:
#                 continue

#             dst_port_rule = r.get("dst_port")
#             dst_port_meta = meta.get("dport")
#             if dst_port_rule is not None and dst_port_meta is not None and dst_port_rule != dst_port_meta:
#                 continue

#             src_port_rule = r.get("src_port")
#             src_port_meta = meta.get("sport")
#             if src_port_rule is not None and src_port_meta is not None and src_port_rule != src_port_meta:
#                 continue

#             pb = entry.get("pattern_bytes")
#             if pb and pb in p:
#                 hits.append((rule_id(r), r.get("message"), "BYTES_raw"))
#                 continue

#             regex = entry.get("pattern_regex_compiled")
#             if regex:
#                 for label, txt in variants:
#                     if regex.search(txt):
#                         hits.append((rule_id(r), r.get("message"), f"REGEX_{label}"))
#                         break

#         # Nếu match rule, log vào ALERTS, không log vào TRAFFIC
#         if hits:
#             for rid, message, variant in hits:
#                 h = hashlib.sha1(f"{rid}|{meta.get('src')}|{meta.get('dst')}|{variant}|{len(p)}".encode()).hexdigest()[:12]
#                 if self.should_throttle(h):
#                     console_logger.debug("throttled alert %s", h)
#                     continue
#                 try:
#                     #lấy thêm action trong rules chứa alerts để biết mức độ nghiêm trọng của alert
#                     if rid in self.rules:
#                         meta["action"] = self.rules[rid].get("action", "unknown")
#                         meta["severity"] = self.rules[rid].get("severity", "medium")
#                     else:
#                         meta["action"] = "unknown"
#                         meta["severity"] = "medium"
#                     action = meta["action"]
#                     severity = meta["severity"]
#                     self.log_alert(meta, p, rid, message, variant, action, severity)
# #fix:
#                     if action.lower() == "block" and str(meta.get("src")) != "127.0.0.1":
#                         src_ip = meta.get("src")
#                         if src_ip:
#                             try:
#                                 enqueue_block(src_ip, reason=f"IDS rule {rid} triggered block action")
#                                 console_logger.info("Enqueued block for %s", src_ip)
#                             except Exception:
#                                 console_logger.exception("enqueue_block error")
#                 except Exception:
#                     console_logger.exception("log_alert error")
#         else:
#             # Nếu không match rule, mới log traffic
#             try:
#                 self.log_traffic(meta, payload)
#             except Exception:
#                 console_logger.exception("log_traffic error")